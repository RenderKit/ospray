// Copyright 2009-2020 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "Material.ih"
#include "camera/Camera.ih"
#include "fb/FrameBuffer.ih"
#include "fb/Tile.ih"
#include "texture/Texture2D.ih"

struct Renderer;
struct World;
struct Camera;

struct ScreenSample
{
  // input values to 'renderSample'
  vec3i sampleID; // x/y=pixelID, z=accumID/sampleID
  vec2f pos; // normalized screen position
  Ray ray; // the primary ray generated by the camera

  // return values from 'renderSample'
  vec3f rgb;
  float alpha;
  float z;
  vec3f normal;
  vec3f albedo;
};

inline void setTile(uniform Tile &tile,
    const varying uint32 pixel,
    const varying ScreenSample screenSample)
{
  setRGBAZ(tile, pixel, screenSample.rgb, screenSample.alpha, screenSample.z);
  setNormalAlbedo(tile, pixel, screenSample.normal, screenSample.albedo);
}

/*! Render a given screen sample (as specified in sampleID), and
  returns the radiance in 'retVal'. sampleID.x and .y refer to the
  pixel ID in the frame buffer, sampleID.z indicates that this should
  be the 'z'th sample in a sequence of samples for renderers that
  support multi-sampling and/or accumulation.

  Note that it is perfectly valid for different samples to have the
  same x, y, or even z values. For example, a accumulation-based
  renderer may issue chunks of pixels with sampleID.z all 0 in the
  first frame, sampleID.z all 1 in the second, etc, while a
  super-sampling renderer make issue a chunk of N samples together for
  the same pixel coordinates in the same call.
 */
typedef void (*Renderer_RenderSampleFct)(Renderer *uniform self,
    FrameBuffer *uniform fb,
    World *uniform model,
    void *uniform perFrameData,
    varying ScreenSample &retValue);

typedef unmasked void (*Renderer_RenderTileFct)(Renderer *uniform self,
    FrameBuffer *uniform fb,
    Camera *uniform camera,
    World *uniform model,
    void *uniform perFrameData,
    uniform Tile &tile,
    uniform int taskIndex);

struct Renderer
{
  Renderer_RenderSampleFct renderSample;
  Renderer_RenderTileFct renderTile;

  void *cppEquivalent;

  int32 spp;
  vec4f bgColor; // background color and alpha
  Texture2D *backplate;
  Texture2D *maxDepthTexture; // optional maximum depth texture used for early
                              // ray termination
  int maxDepth;
  float minContribution;

  int32 numMaterials;
  Material **material;
};

vec4f Renderer_getBackground(
    const Renderer *uniform self, const vec2f &screenPos);
float Renderer_getMaxDepth(
    const Renderer *uniform self, const vec2f &screenPos);

void Renderer_Constructor(Renderer *uniform self, void *uniform cppE);
