// ======================================================================== //
// Copyright 2009-2018 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "../common/OSPCommon.ih"
#include "../fb/FrameBuffer.ih"
#include "../fb/Tile.ih"
#include "../common/Ray.ih"
#include "../texture/Texture2D.ih"

struct Renderer;
struct Model;
struct Camera;


struct ScreenSample {
  // input values to 'renderSample'
  vec3i sampleID; /*!< x/y=pixelID,z=accumID/sampleID */
  Ray   ray;      /*!< the primary ray generated by the camera */
  // return values from 'renderSample'
  vec3f rgb;
  float alpha;
  float z;
};

/*! Render a given screen sample (as specified in sampleID), and
  returns the radiance in 'retVal'. sampleID.x and .y refer to the
  pixel ID in the frame buffer, sampleID.z indicates that this should
  be the 'z'th sample in a sequence of samples for renderers that
  support multi-sampling and/or accumulation.

  Note that it is perfectly valid for different samples to have the
  same x, y, or even z values. For example, a accumulation-based
  renderer may issue chunks of pixels with sampleID.z all 0 in the
  first frame, sampleID.z all 1 in the second, etc, while a
  super-sampling renderer make issue a chunk of N samples together for
  the same pixel coordinates in the same call.
 */
typedef void (*Renderer_RenderSampleFct)(uniform Renderer *uniform self,
                                         void *uniform perFrameData,
                                         varying ScreenSample &retValue);
typedef unmasked void (*Renderer_RenderTileFct)(uniform Renderer *uniform self,
                                       void *uniform perFrameData,
                                       uniform Tile &tile,
                                       uniform int taskIndex);
typedef unmasked void *uniform (*Renderer_BeginFrameFct)(uniform Renderer *uniform self,
                                       uniform FrameBuffer *uniform fb);
typedef unmasked void (*Renderer_EndFrameFct)(uniform Renderer *uniform self,
                                     void *uniform perFrameData);

struct Renderer {
  Renderer_RenderSampleFct renderSample;
  Renderer_RenderTileFct   renderTile;
  Renderer_BeginFrameFct   beginFrame;
  Renderer_EndFrameFct     endFrame;

  void        *cppEquivalent;

  FrameBuffer *fb; /*!< currently rendered frame buffer. may be NULL
                     or invalid before start of, or after end of, a
                     frame */
  Model       *uniform model;
  Camera      *camera;
  bool         autoEpsilon; // flag whether to compute epsilon automatically/adaptively
  float        epsilon; // parameter to prevent self-intersection issues, will be scaled with diameter of the scene
  int32        spp; // number of samples per pixel; negative values mean subsampling, i.e. render only every 2^-spp pixel in x and y for the first frame
  vec4f bgColor;// background color and alpha
  Texture2D *maxDepthTexture; // optional maximum depth texture used for early ray termination
  int maxDepth;
  float minContribution;
};

void Renderer_Constructor(uniform Renderer *uniform self, void *uniform cppE);
void Renderer_Constructor(uniform Renderer *uniform self,
                          void *uniform cppE,
                          void *uniform _model,
                          void *uniform _camera,
                          const uniform int32 spp);

