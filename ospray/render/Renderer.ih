// ======================================================================== //
// Copyright 2009-2019 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "camera/Camera.ih"
#include "common/World.ih"
#include "fb/FrameBuffer.ih"
#include "fb/Tile.ih"
#include "texture/Texture2D.ih"

struct Renderer;
struct World;
struct Camera;

struct ScreenSample
{
  // input values to 'renderSample'
  vec3i sampleID; /*!< x/y=pixelID,z=accumID/sampleID */
  Ray ray;        /*!< the primary ray generated by the camera */

  // return values from 'renderSample'
  vec3f rgb;
  float alpha;
  float z;
  vec3f normal;
  vec3f albedo;
};

inline void setTile(uniform Tile &tile,
                    const varying uint32 pixel,
                    const varying ScreenSample screenSample)
{
  setRGBAZ(tile, pixel, screenSample.rgb, screenSample.alpha, screenSample.z);
  setNormalAlbedo(tile, pixel, screenSample.normal, screenSample.albedo);
}

/*! Render a given screen sample (as specified in sampleID), and
  returns the radiance in 'retVal'. sampleID.x and .y refer to the
  pixel ID in the frame buffer, sampleID.z indicates that this should
  be the 'z'th sample in a sequence of samples for renderers that
  support multi-sampling and/or accumulation.

  Note that it is perfectly valid for different samples to have the
  same x, y, or even z values. For example, a accumulation-based
  renderer may issue chunks of pixels with sampleID.z all 0 in the
  first frame, sampleID.z all 1 in the second, etc, while a
  super-sampling renderer make issue a chunk of N samples together for
  the same pixel coordinates in the same call.
 */
typedef void (*Renderer_RenderSampleFct)(Renderer *uniform self,
                                         FrameBuffer *uniform fb,
                                         World *uniform model,
                                         void *uniform perFrameData,
                                         varying ScreenSample &retValue);

typedef unmasked void (*Renderer_RenderTileFct)(Renderer *uniform self,
                                                FrameBuffer *uniform fb,
                                                Camera *uniform camera,
                                                World *uniform model,
                                                void *uniform perFrameData,
                                                uniform Tile &tile,
                                                uniform int taskIndex);

struct Renderer
{
  Renderer_RenderSampleFct renderSample;
  Renderer_RenderTileFct renderTile;

  void *cppEquivalent;

  int32 spp;
  vec4f bgColor;               // background color and alpha
  Texture2D *maxDepthTexture;  // optional maximum depth texture used for early
                               // ray termination
  int maxDepth;
  float minContribution;
};

void Renderer_Constructor(uniform Renderer *uniform self, void *uniform cppE);
void Renderer_Constructor(uniform Renderer *uniform self,
                          void *uniform cppE,
                          const uniform int32 spp);
