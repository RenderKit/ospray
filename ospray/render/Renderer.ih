// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "ospray/common/OSPCommon.ih"
#include "ospray/fb/FrameBuffer.ih"
#include "ospray/fb/Tile.ih"
#include "ospray/common/Ray.ih"

struct Renderer;
struct Model;
struct Camera;

struct OSPPickData {
  bool hit;
  float world_x, world_y, world_z;
};


struct ScreenSample {
  // input values to 'renderSample'
  vec3i sampleID; /*!< x/y=pixelID,z=accumID/sampleID */
  Ray   ray;      /*!< the primary ray generated by the camera */
  // return values from 'renderSample'
  vec3f rgb;      
  float alpha;
  float z;
};

/*! Render a given screen sample (as specified in sampleID), and
  returns the radiance in 'retVal'. sampleID.x and .y refer to the
  pixel ID in the frame buffer, sampleID.z indicates that this should
  be the 'z'th sample in a sequence of samples for renderers that
  support multi-sampling and/or accumulation. 

  Note that it is perfectly valid for different samples to have the
  same x, y, or even z values. For example, a accumulation-based
  renderer may issue chunks of pixels with sampleID.z all 0 in the
  first frame, sampleID.z all 1 in the second, etc, while a
  super-sampling renderer make issue a chunk of N samples together for
  the same pixel coordinates in the same call.
 */
typedef void (*Renderer_RenderSampleFct)(uniform Renderer *uniform renderer,
                                      varying ScreenSample &retValue);
typedef void (*Renderer_ToneMapFct)(uniform Renderer *uniform renderer,
                                 varying vec3f &color,
                                 const varying vec2i &pixelID);
typedef void (*Renderer_RenderTileFct)(uniform Renderer *uniform renderer,
                                    uniform Tile &tile);
typedef void (*Renderer_BeginFrameFct)(uniform Renderer *uniform renderer,
                                       uniform FrameBuffer *uniform fb);
typedef void (*Renderer_EndFrameFct)(uniform Renderer *uniform renderer, 
                                     const uniform int32 newAccumID);

struct Renderer {
  Renderer_RenderSampleFct renderSample;
  Renderer_ToneMapFct      toneMap;
  Renderer_RenderTileFct   renderTile;
  Renderer_BeginFrameFct   beginFrame;
  Renderer_EndFrameFct     endFrame;

  FrameBuffer *fb; /*!< currently rendered frame buffer. may be NULL
                     or invalid before start of, or after end of, a
                     frame */
  Model       *model; 
  Camera      *camera;
  void        *cppEquivalent;
  uint32       spp; // number of samples per pixel
  float        nearClip;
};

void Renderer_constructor(uniform Renderer *uniform renderer,
                          void *uniform cppE,
                          void *uniform _model,
                          void *uniform _camera);

